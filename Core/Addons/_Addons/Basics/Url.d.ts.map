{"version":3,"sources":["Addons/YetaWF/Core/_Addons/Basics/Url.ts"],"names":[],"mappings":"AAEA,kBAAU,MAAM,CAAC;IAEb,UAAiB,OAAO;QACpB,GAAG,EAAE,MAAM,CAAC;QACZ,QAAQ,EAAE,MAAM,CAAC;QACjB,KAAK,EAAE,MAAM,CAAC;KACjB;IAED;;;OAGG;IACH,MAAa,GAAG;QAEZ,OAAO,CAAC,MAAM,CAAc;QAC5B,OAAO,CAAC,QAAQ,CAAc;QAC9B,OAAO,CAAC,MAAM,CAAc;QAC5B,OAAO,CAAC,IAAI,CAAc;QAC1B,OAAO,CAAC,IAAI,CAAgB;QAC5B,OAAO,CAAC,IAAI,CAAc;QAC1B,OAAO,CAAC,SAAS,CAAiB;QAE3B,SAAS,IAAI,MAAM;QAGnB,WAAW,IAAI,MAAM;QAGrB,OAAO,IAAI,MAAM;QAGjB,WAAW,CAAC,MAAM,CAAC,EAAE,OAAO,GAAG,MAAM;QAGrC,SAAS,IAAI,MAAM;QAMnB,OAAO,IAAI,MAAM;QAOjB,OAAO,CAAC,QAAQ,CAAC,EAAE,OAAO,GAAG,MAAM;QAInC,SAAS,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO;QAQ/B,SAAS,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM;QAQ9B,eAAe,IAAI,MAAM;QAOzB,eAAe,CAAC,CAAC,EAAE,MAAM,GAAG,IAAI;QAOhC,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,IAAI;QAG3D,qBAAqB,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI;QAOrC,WAAW,CAAC,GAAG,EAAE,WAAW,EAAE,OAAO,CAAC,EAAE,MAAM,GAAG,IAAI;QAOrD,YAAY,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;QAQ/B,QAAQ,CAAC,YAAY,CAAC,EAAE,OAAO,GAAG,MAAM;QAaxC,KAAK,IAAI,MAAM;QAMf,UAAU,IAAI,MAAM;QAGpB,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;KAyElC;CACJ","file":"Url.d.ts","sourcesContent":["/* Copyright Â© 2019 Softel vdm, Inc. - https://yetawf.com/Documentation/YetaWF/Licensing */\r\n\r\nnamespace YetaWF {\r\n\r\n    export interface QSEntry {\r\n        key: string;\r\n        keyLower: string;\r\n        value: string;\r\n    }\r\n\r\n    /**\r\n     * Url Parsing (simple parsing to replace uri.js, limited to functionality needed by YetaWF)\r\n     * parses https://user:123@sub.domain.com[:80]/path?querystring#hash\r\n     */\r\n    export class Url {\r\n\r\n        private Schema: string = \"\";\r\n        private UserInfo: string = \"\";\r\n        private Domain: string = \"\";\r\n        private Port: string = \"\";\r\n        private Path: string[] = [];\r\n        private Hash: string = \"\";\r\n        private QSEntries: QSEntry[] = [];\r\n\r\n        public getSchema(): string {\r\n            return this.Schema;\r\n        }\r\n        public getHostName(): string {\r\n            return this.Domain;\r\n        }\r\n        public getPort(): string {\r\n            return this.Port;\r\n        }\r\n        public getUserInfo(withAt?: boolean): string {\r\n            return this.UserInfo + (withAt && this.UserInfo.length > 0 ? \"@\" : \"\");\r\n        }\r\n        public getDomain(): string {\r\n            if (this.Port)\r\n                return encodeURIComponent(this.Domain) + \":\" + encodeURIComponent(this.Port);\r\n            else\r\n                return encodeURIComponent(this.Domain);\r\n        }\r\n        public getPath(): string {\r\n            var path = \"\";\r\n            for (let part of this.Path) {\r\n                path += \"/\" + encodeURIComponent(part);\r\n            }\r\n            return path;\r\n        }\r\n        public getHash(withHash?: boolean): string {\r\n            if (this.Hash.length === 0) return \"\";\r\n            return (withHash ? \"#\" : \"\") + encodeURIComponent(this.Hash);\r\n        }\r\n        public hasSearch(key: string): boolean {\r\n            key = key.toLowerCase();\r\n            for (let entry of this.QSEntries) {\r\n                if (entry.keyLower === key)\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        public getSearch(key: string): string {\r\n            key = key.toLowerCase();\r\n            for (let entry of this.QSEntries) {\r\n                if (entry.keyLower === key)\r\n                    return entry.value;\r\n            }\r\n            return \"\";\r\n        }\r\n        public getSearchObject(): object {\r\n            var o: any = {};\r\n            for (let entry of this.QSEntries) {\r\n                o[entry.key] = entry.value;\r\n            }\r\n            return o;\r\n        }\r\n        public setSearchObject(o: object): void {\r\n            this.QSEntries = [];\r\n            // tslint:disable-next-line:forin\r\n            for (let prop in o) {\r\n                this.QSEntries.push({ key: prop, keyLower: prop.toLowerCase(), value: o[prop] });\r\n            }\r\n        }\r\n        public addSearch(key: string, value: string | number | null): void {\r\n            this.QSEntries.push({ key: key, keyLower: key.toLowerCase(), value: value == null ? \"\" : value.toString() });\r\n        }\r\n        public addSearchSimpleObject(obj: any): void {\r\n            for (const key in obj) {\r\n                if (obj.hasOwnProperty(key)) {\r\n                    this.addSearch(key, obj[key]);\r\n                }\r\n            }\r\n        }\r\n        public addFormInfo(tag: HTMLElement, counter?: number): void {\r\n            var formInfo = $YetaWF.Forms.getFormInfo(tag, undefined, counter);\r\n            this.addSearch(YConfigs.Forms.RequestVerificationToken, formInfo.RequestVerificationToken);\r\n            this.addSearch(YConfigs.Forms.UniqueIdPrefix, formInfo.UniqueIdPrefix);\r\n            this.addSearch(YConfigs.Basics.ModuleGuid, formInfo.ModuleGuid);\r\n            this.addSearch(YConfigs.Basics.Link_CharInfo, formInfo.CharInfo);\r\n        }\r\n        public removeSearch(key: string): void {\r\n            key = key.toLowerCase();\r\n            for (var i = this.QSEntries.length - 1; i >= 0; --i) {\r\n                var entry = this.QSEntries[i];\r\n                if (entry.keyLower === key)\r\n                    this.QSEntries.splice(i, 1);\r\n            }\r\n        }\r\n        public getQuery(withQuestion?: boolean): string {\r\n            var qs: string = \"\";\r\n            for (let entry of this.QSEntries) {\r\n                if (qs !== \"\")\r\n                    qs += \"&\";\r\n                else if (withQuestion)\r\n                    qs += \"?\";\r\n                qs += encodeURIComponent(entry.key) + \"=\";\r\n                if (entry.value !== null)\r\n                    qs += encodeURIComponent(entry.value);\r\n            }\r\n            return qs;\r\n        }\r\n        public toUrl(): string {\r\n            if (this.Schema.length === 0 && this.UserInfo.length === 0 && this.Domain.length === 0)\r\n                return `${this.getPath()}${this.getQuery(true)}${this.getHash(true)}`;\r\n            else\r\n                return `${this.getSchema()}//${this.getUserInfo(true)}${this.getDomain()}${this.getPath()}${this.getQuery(true)}${this.getHash(true)}`;\r\n        }\r\n        public toFormData(): string {\r\n            return this.getQuery();\r\n        }\r\n        public parse(url: string): void {\r\n\r\n            this.Schema = \"\";\r\n            this.UserInfo = \"\";\r\n            this.Domain = \"\";\r\n            this.Port = \"\";\r\n            this.Path = [];\r\n            this.Hash = \"\";\r\n            this.QSEntries = [];\r\n\r\n            // remove hash\r\n            var parts = url.split(\"#\");\r\n            if (parts.length === 0) return;\r\n            url = parts[0];\r\n            if (parts.length > 1)\r\n                this.Hash = decodeURIComponent(parts.slice(1).join());\r\n\r\n            // remove qs\r\n            parts = url.split(\"?\");\r\n            url = parts[0];\r\n            var qs = \"\";\r\n            if (parts.length > 1)\r\n                qs = parts.slice(1).join(\"?\");\r\n\r\n            // process path\r\n\r\n            // scheme\r\n            parts = url.split(\"//\");\r\n            if (parts.length > 1) {\r\n                this.Schema = parts[0];\r\n                url = parts.slice(1).join(\"//\");\r\n            } else {\r\n                url = parts[0];\r\n            }\r\n\r\n            // extract everything left of user info\r\n            parts = url.split(\"@\");\r\n            if (parts.length > 1) {\r\n                this.UserInfo = parts[0]; // do not decode because we're not encoding, changes not supported\r\n                url = parts.slice(1).join(\"@\");\r\n            } else\r\n                url = parts[0];\r\n\r\n            var domain = \"\";\r\n            parts = url.split(\"/\");\r\n            if (parts.length > 1) {\r\n                domain = parts[0];\r\n                parts = parts.slice(1);\r\n                for (let i in parts)\r\n                    parts[i] = decodeURIComponent(parts[i]);\r\n                this.Path = parts;\r\n            } else\r\n                this.Path = [\"\"];\r\n\r\n            if (domain) {\r\n                parts = domain.split(\":\");\r\n                this.Domain = parts[0];\r\n                if (parts.length > 1)\r\n                    this.Port = parts.slice(1).join(\"//\");\r\n            }\r\n\r\n            // split up query string\r\n            if (qs.length > 0) {\r\n                var qsArr = qs.split(\"&\");\r\n                for (let qsEntry of qsArr) {\r\n                    var entryParts = qsEntry.split(\"=\");\r\n                    if (entryParts.length > 2)\r\n                        throw `Url has malformed query string entry ${qsEntry}`;\r\n                    var key = decodeURIComponent(entryParts[0]);\r\n                    this.QSEntries.push({ key: key, keyLower: key.toLowerCase(), value: entryParts.length > 1 ? decodeURIComponent(entryParts[1]) : \"\" });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"]}